# https://docs.percona.com/percona-xtradb-cluster/8.0/apt.html#install-from-repository
---
- name: Install Percona XtraDB Cluster
  hosts: PerconaCluster
  gather_facts: yes
  become: yes

  vars:
    prerequisite_packages:
      - wget
      - gnupg2
      - lsb-release
      - curl
      - python3-pexpect
    ssl_certs: # These will be filled in by the HashiCorp Vault lookup in this playbook
      cert: "{{ ssl_certs.cert }}"
      chain: "{{ ssl_certs.chain }}"
      fullchain: "{{ ssl_certs.fullchain }}"
      privkey: "{{ ssl_certs.privkey }}"

  vars_files:
    - ../../../vault.yml

  tasks:
#    - name: Update apt repository cache
#      ansible.builtin.apt:
#        update_cache: yes
#
#    - name: Install prerequisite packages
#      package:
#        name: "{{ prerequisite_packages }}"
#        state: present
#
#    - name: Download the repository package
#      ansible.builtin.get_url:
#        url: "https://repo.percona.com/apt/percona-release_latest.generic_all.deb"
#        dest: "/tmp/percona-release_latest.generic_all.deb"
#
#    - name: Install the package with dpkg
#      ansible.builtin.apt:
#        deb: "/tmp/percona-release_latest.generic_all.deb"
#
#    - name: Refresh the local cache to update the package information
#      ansible.builtin.apt:
#        update_cache: yes
#
#    - name: Enable the release repository for Percona XtraDB Cluster
#      ansible.builtin.shell: percona-release setup pxc80
#
    - name: Retrieve MySQL Root user password from HashiCorp Vault
      # NOTE: This password is created manually and stored in vault at path below. 36 characters generated by random.org
      set_fact:
        percona_creds: "{{ lookup('hashi_vault', 'secret=kv/data/percona_cluster/pxc-cluster token={{ hashicorp_vault_token }} url={{ hashicorp.vault.address }}') }}"
      no_log: true
#
#    - name: Install the Percona XtraDB Cluster package
#      expect:
#        command: apt-get -y install percona-xtradb-cluster
#        responses:
#          'Enter root password:': '{{ percona_creds.root_password }}'
#          'Re-enter root password:': '{{ percona_creds.root_password }}'
#          'Select default authentication plugin': '1'
##   1. Use Strong Password Encryption (RECOMMENDED)  2. Use Legacy Authentication Method (Retain MySQL 5.x Compatibility)
#        echo: yes
#      environment:
#        DEBIAN_FRONTEND: readline
#        # By default, the installer will use a dialog interface to get user input.
#        # This will force it to use readline instead so that the expect module can interact with it.
#      no_log: true
#      ignore_errors: yes # I don't know why when done manually this works, but when automated it fails. But it does work and the issue is addressed in the next task.
#
#    - name: Check if dpkg lock file exists
#      ansible.builtin.stat:
#        path: /var/lib/dpkg/lock
#      register: lock_file_stat
#
#    - name: Wait for dpkg lock to be released
#      ansible.builtin.wait_for:
#        path: /var/lib/dpkg/lock
#        state: absent
#        timeout: 20 # this shouldn't take long
#      when: lock_file_stat.stat.exists
#      ignore_errors: yes # This is to ignore the error when the lock file is not found. The file can appear and disappear very fast.
#
#    # For some reason, the previous step installs the package, but it misses a configuration step that we to address below.
#    - name: Configure apparmor
#      expect:
#        command: dpkg --configure -a
#        responses:
#          'Select which AppArmor profile should be used': '1'
#          # It was detected that there is /etc/apparmor.d/(local)/usr.sbin.mysqld or/and /etc/apparmor.d/usr.bin.wsrep_sst_xtrabackup-v2 file on the system. Probably it comes from previous setup and may contain custom changes. Please decide should it be replaced or not.
#          #  1. Use existent AppArmor profile (RECOMMENDED)  2. Use NEW AppArmor profile
#      ignore_errors: yes
# #########
#    - name: Start the Percona XtraDB Cluster service
#      ansible.builtin.systemd:
#        name: mysql
#        state: started
#        enabled: yes
#
#    - name: Verify MySQL login
#      command: mysql -u root -e 'SELECT 1;'
#      environment:
#        MYSQL_PWD: "{{ percona_creds.root_password }}"
#      register: result
#      failed_when: "'ERROR' in result.stderr"
#      no_log: true
#
#    - name: Grant remote priviliges for MySQL Server
#      mysql_user:
#        name: root
#        host: "%"
#        password: "{{ percona_creds.root_password }}"
#        priv: "*.*:ALL,GRANT"
#        state: present
#      when: bootstrap is defined and bootstrap == "True"
#
#    - name: Create SST User for Percona Syncing
#      mysql_user:
#        name: sstuser
#        host: "%"
#        password: "{{ percona_creds.sstuser_password }}"
#        priv: "*.*:ALL"
#        state: present
#      when: bootstrap is defined and bootstrap == "True"
#
#    - name: Flush privileges
#      mysql_query:
#        login_user: root
#        login_password: "{{ percona_creds.root_password }}"
#        query: "FLUSH PRIVILEGES;"
#      when: bootstrap is defined and bootstrap == "True"
#
#    - name: Stop the Percona XtraDB Cluster service
#      ansible.builtin.systemd:
#        name: mysql
#        state: stopped
#
#    - name: Configure mysqld.cnf
#      template:
#        src: templates/mysqld.cnf.j2
#        dest: /etc/mysql/mysql.conf.d/mysqld.cnf
# #############
#    - name: Creating directory for SSL Certs
#      ansible.builtin.file:
#        path: /etc/mysql/certs/
#        state: directory
#        mode: '0700'

#    - name: Retrieving SSL Certs for levantine.io
#      set_fact:
#        ssl_certs: "{{ lookup('hashi_vault', 'secret=kv/data/ssl_certs/levantine_io token={{ hashicorp_vault_token }} url={{ hashicorp.vault.address }}') }}"
#
#    - name: Configure SSL Certs for percona cluster
#      copy:
#        content: "{{ ssl_certs[item] }}"
#        dest: /etc/mysql/certs/{{ item }}.pem
#      with_items:
#        "{{ ssl_certs }}"
#      register: levantine_certs

    - name: Debug bootstrap variable
      ansible.builtin.debug:
          msg: "Bootstrap: {{ bootstrap }}"
      when: bootstrap is defined